<!doctype html>
<html>


<!-- Mirrored from www.cdf.toronto.edu/~ajr/209/tut/12/q13s.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 13 Jan 2017 00:59:27 GMT -->
<head>

<title>CSC 209 sample exam question solution</title>

<meta name=viewport content="width=device-width, initial-scale=1">

<style type="text/css">
    body {
        color: black;
        background-color: #ffdddd;
    }
    hr {
        border-style: solid;
    }
    div.toc {
        float: right;
        padding-left: 20px;
        padding-right: 20px;
        padding-top: 20px;
        padding-bottom: 20px;
        background-color: #cc7777;
        color: white;
        link: white;
        visited: white;
        line-height: 150%;
    }
    div.toc a:link {
        color: white;
    }
    div.toc a:visited {
        color: white;
    }

    .hidden { display: none; }
    .unhidden { display: block; }
</style>

</head>

<body>

<h4>An answer:</h4>

<pre>
#include &lt;stdio.h>
#include &lt;unistd.h>
#include &lt;string.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;netinet/in.h>

int main()
{
    int listenfd, clientfd, len;
    struct sockaddr_in r, q;
    static char *files[3] = { "1", "2", "3" };
    int whichfile = 0;
    FILE *fp;
    int c;

    if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) {
        perror("socket");
        return(1);
    }

    memset(&amp;r, '\0', sizeof r);
    r.sin_family = AF_INET;
    r.sin_addr.s_addr = INADDR_ANY;
    r.sin_port = htons(1234);
    if (bind(listenfd, (struct sockaddr *)&amp;r, sizeof r) &lt; 0) {
        perror("bind");
        return(1);
    }
    if (listen(listenfd, 5)) {
        perror("listen");
        return(1);
    }

    while (1) {
        len = sizeof q;
        if ((clientfd = accept(listenfd, (struct sockaddr *)&amp;q, &amp;len)) &lt; 0) {
            perror("accept");
            return(1);
        }
        if ((fp = fopen(files[whichfile], "r")) == NULL) {
            perror(files[whichfile]);
        } else {
            while ((c = getc(fp)) != EOF) {
                if (c == '\n') {
                    write(clientfd, "\r\n", 2);
                } else {
                    char cc = c;
                    write(clientfd, &amp;cc, 1);
                }
            }
            fclose(fp);
            whichfile = (whichfile + 1) % 3;
        }
        close(clientfd);
    }
}
</pre>

<p>
Note: write()ing a single character at a time will make for a really slow
program.  In real life, buffering would be essential.  I would use fdopen() to
make a "FILE *" out of the socket (see the fdopen man page), then write to
it with putchar, then fclose() it to close the socket.
<br>
Actually, this program is no longer -- even shorter.  See below.

<p>
Note 2: When we go to do the write("\r\n"), passing <tt>sizeof "\r\n"</tt> as
the length parameter would be quite wrong, because that size would be 3.
If you're not sure why, you should think about it and/or ask.

<p>
Note 3: When we go to write the character 'c', we cannot call write(clientfd,
&amp;c, 1), because c is an int, not a char.  On "big-endian" machines, in
fact, this would write a zero byte every time in the above loop
(again, figure out why!).
We also cannot make the 'c' variable be a char.
This is because getc() returns -1 for EOF, and returns 255
if there is a 255 byte read in; as an eight bit value, these are identical,
which is a big problem.  Alternately put, getc() can return any of the 256
possible eight-bit values OR it can return -1 for EOF; this is 257 possible
values, which cannot be stored in an 8-bit variable, because eight bits can
be in only 2<sup>8</sup> possible states.

<p>
<hr align=left width="25%">

<p>
Here's the fdopen version, which will be faster for significantly-sized files
or for a significant number of requests.

<p>
(Note, however, that this strategy is not suitable for your assignment four.
In the case below, the buffering isn't a problem because we're fclosing the
file anyway, which flushes all buffers.)

<p>
<pre>
#include &lt;stdio.h>
#include &lt;unistd.h>
#include &lt;string.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;netinet/in.h>

int main()
{
    int listenfd, clientfd, len;
    struct sockaddr_in r, q;
    static char *files[3] = { "1", "2", "3" };
    int whichfile = 0;
    FILE *fp, *ofp;
    int c;

    if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) {
        perror("socket");
        return(1);
    }

    memset(&amp;r, '\0', sizeof r);
    r.sin_family = AF_INET;
    r.sin_addr.s_addr = INADDR_ANY;
    r.sin_port = htons(1234);
    if (bind(listenfd, (struct sockaddr *)&amp;r, sizeof r) &lt; 0) {
        perror("bind");
        return(1);
    }
    if (listen(listenfd, 5)) {
        perror("listen");
        return(1);
    }

    while (1) {
        len = sizeof q;
        if ((clientfd = accept(listenfd, (struct sockaddr *)&amp;q, &amp;len)) &lt; 0) {
            perror("accept");
            return(1);
        }
        if ((fp = fopen(files[whichfile], "r")) == NULL) {
            perror(files[whichfile]);
            close(clientfd);
        } else if ((ofp = fdopen(clientfd, "w")) == NULL) {
            fprintf(stderr, "can't allocate stdio data\n");
            close(clientfd);
        } else {
            while ((c = getc(fp)) != EOF) {
                if (c == '\n')
                    putc('\r', ofp);
                putc(c, ofp);
            }
            fclose(fp);
            fclose(ofp);  /* which also does close(clientfd) */
            whichfile = (whichfile + 1) % 3;
        }
    }
}
</pre>

<p>
<hr>
[press 'back' in your web browser to return to where you were in the exam]

</body>

<!-- Mirrored from www.cdf.toronto.edu/~ajr/209/tut/12/q13s.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 13 Jan 2017 00:59:27 GMT -->
</html>

<!doctype html>
<html>


<!-- Mirrored from www.cdf.toronto.edu/~ajr/209/tut/09/05.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 13 Jan 2017 00:59:27 GMT -->
<head>

<title> CSC 209 tutorial exercises, week of 14 March 2016 </title>

<meta name=viewport content="width=device-width, initial-scale=1">

<style type="text/css">
    body {
        color: black;
        background-color: #ffdddd;
    }
    hr {
        border-style: solid;
    }
    div.toc {
        float: right;
        padding-left: 20px;
        padding-right: 10px;
        padding-top: 15px;
        padding-bottom: 0px;
        background-color: #dd9088;
        border-style: solid;
        border-color: green;
        color: white;
        link: white;
        visited: white;
        line-height: 150%;
    }
    div.toc a:link {
        color: white;
    }
    div.toc a:visited {
        color: white;
    }

    .hidden { display: none; }
    .revealed { display: block; }
</style>

<script type="text/javascript">
function reveal(s) {
    document.getElementById(s+'_a').className = 'hidden';
    document.getElementById(s+'_b').className = 'revealed';
}
</script>

</head>

<body>

<div class=toc>

1. <a href=".html">Tutorial 9 intro</a>
<br>
2. <a href="02.html">Traversing</a>
<br>
3. <a href="03.html">Searching</a>
<br>
4. <a href="04.html">Inserting</a>
<br>
5. <a href="05.html">Better insert</a>
<br>
6. <a href="06.html">Deleting</a>

<p>
[<a href="../index.html">All tutorials</a>]
<br>
[<a href="../../index.html">Course home page</a>]

</div>
<h1> A better way to insert into a linked list in C </h1>

To avoid an 'if' statement where we assign either to "head" or to
"something->next", since these are both "struct item *" variables we can use
a pointer to "struct item *".  In other words, a "struct item **".

<p>
After writing
<pre>
	struct item **pp;
</pre>
, it is suitable to assign "&amp;head" to pp.

<p>
Then accesses formerly to 'p' now can be made to "*pp".

<p>
Instead of "p = p->next;", we would now need to write the slightly awesome
<pre>
	pp = &amp;(*pp)->next;
</pre>
The "&amp;" is applying to all of "(*pp)->next"; no further parentheses are
needed there.
However, the parentheses around "*pp" are needed because of the operator
precedence.
So this is slightly awkward.
(But it will be worth it below!)

<p>
Let's look at the new-style loop
<pre>
	for (pp = &amp;head; *pp; pp = &amp;(*pp)->next)
</pre>
and compare it to the old-style loop
<pre>
	for (p = head; p; p = p->next)
</pre>
In all cases, 'pp' in the first is a pointer to a variable containing the
same value as 'p' in the second.
Specifically, pp is a pointer to the variable containing the pointer
to the struct-item we're looking at
(whether it's stored in 'head' or in some other item's 'next' value).
<br>
So if the linked list is of length at least three, and p ends up being the
values of head, head->next, and head->next->next in subsequent loop iterations;
<br>
then pp will be the values &head, &head->next, and &head->next->next in
subsequent loop iterations.

<p>
So it doesn't sound so different so far.
But we then have a very useful situation once we do find the item.
Instead of the 'if's around whether this new item is going at the head of the
list or in the middle, we can simply write:
<pre>
	new->next = *pp;
	*pp = new;
</pre>
and this takes care of both cases:
<br>
If pp is still a pointer to 'head', this assigns new->next the former value of
'head', and changes 'head' to point to the new item.
<br>
If pp is a pointer to the 'next' field in some struct item, this assigns
new->next to the former value of that 'next' field , and changes that 'next'
field to point to the new item.

<p>
Eliminating these special cases is good.
Code for this revised style of linked-list manipulation is slightly more
complex in one sense, but that's something about pointers which you will get
more and more used to.  And it's simpler in all other respects.
Once you are comfortable with all these pointers, it will be less error-prone
to write linked lists in this new style.

<p>
There is, however, no point in revising the search() function to use this new
strategy.  Since search() does not modify the list, nothing would be gained
by having it manipulate pointers to the pointers, instead of the pointers
themselves as it already does.

<p>
So, copy either your 4.c or my 4s.c to a new 5.c,
revise the insert() function to use this new strategy, and
submit your revised file with
<pre>
	/student/csc209/submit tut9 5.c
</pre>
As you can see, the new insert() is <i>much</i> shorter than the other one.

<p>
Solutions from this point forward will be provided only after the tutorial
submission deadline is past.
However, partial marks will be awarded for this tutorial if
you complete at least 2.c, 3.c, and 4.c, and at least 2.c and 3.c work fully,
and all three compile with "gcc&nbsp;-Wall" with no warning or error messages.
(For full marks, of course, you need to complete all five programs, and all
but 4.c need to work fully.)

<p>
<hr>

<p>
Finally, we will write code to <a href="06.html">delete from the linked
list</a>.  It will be much easier to do this using our extra level of
indirection.

<p>
<hr>

</body>

<!-- Mirrored from www.cdf.toronto.edu/~ajr/209/tut/09/05.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 13 Jan 2017 00:59:27 GMT -->
</html>

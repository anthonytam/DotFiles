<!doctype html>
<html>


<!-- Mirrored from www.cdf.toronto.edu/~ajr/209/tut/01/soln.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 13 Jan 2017 00:59:26 GMT -->
<head>

<title>CSC 209 tutorial exercises, week of 11 January 2016</title>

<meta name=viewport content="width=device-width, initial-scale=1">

<style type="text/css">
    body {
        color: black;
        background-color: #ffdddd;
    }
    hr {
        border-style: solid;
    }
    div.toc {
        float: right;
        padding-left: 20px;
        padding-right: 20px;
        padding-top: 20px;
        padding-bottom: 20px;
        background-color: #cc7777;
        color: white;
        link: white;
        visited: white;
        line-height: 150%;
    }
    div.toc a:link {
        color: white;
    }
    div.toc a:visited {
        color: white;
    }

    .hidden { display: none; }
    .unhidden { display: block; }
</style>

<script type="text/javascript">
    function show(s) {
        document.getElementById(s).className = 'unhidden';
    }
    function reveal(s) {
        document.getElementById(s+'_a').className = 'hidden';
        document.getElementById(s+'_b').className = 'revealed';
    }
</script>

</head>

<body>

<div class=toc>
<a href="../01.html">Tutorial 01</a>
<br>
<a href="../02.html">Tutorial 02</a>
<br>
<a href="../03.html">Tutorial 03</a>
<br>
<a href="../04.html">Tutorial 04</a>
<br>
<a href="../05.html">Tutorial 05</a>
<br>
<a href="../06.html">Tutorial 06</a>
<br>
<a href="../07.html">Tutorial 07</a>
<br>
<a href="../08.html">Tutorial 08</a>
<br>
<a href="../09.html">Tutorial 09</a>
<br>
<a href="../10.html">Tutorial 10</a>
<br>
<a href="../11.html">Tutorial 11</a>
<br>
<a href="../12.html">Tutorial 12</a>
<br>
<p>
[<a href="../../index.html">Course home page</a>]
</div>

<h1>CSC 209 tutorial 01 solutions, week of 11 January 2016</h1>

<strong>Note:</strong>
I strongly recommend that you look at
<a href=".html">the other web page which has only the questions</a>,
and try to do them first, and ask your TA or me if you have difficulty.
This solutions web page is intended for use only <strong>after</strong> you
have completed <strong>all of</strong> the exercises as best you can (ideally
in the tutorial time with the TA).

<p>
Note 2:
Most of these exercises have multiple possible answers.
You're welcome to ask questions about these exercises, but before
concluding that your own solution is wrong, try it; and if you want to know
what one of the answers below does, try it!  Don't ask what something does;
try it!  Then ask <i>why</i> it does that.  Or ask how to try it, or ask for
advice on more methodical test procedures than just "trying"... but to
understand these exercises you do have to plunge in and <i>do</i> them,
on the actual computer, rather than just thinking about them completely
abstractly.

<p>
<hr>

<p>
Write a "glob" expression which matches all filenames in the current
directory with the following properties.  Do not worry about the issue of
filenames beginning with a dot.

<ol>
<li> filenames beginning with an 'a'
    <br> Answer: &nbsp;<tt>a*</tt>
<li> filenames ending with a 'c'
    <br> Answer: &nbsp;<tt>*c</tt>
<li> filenames containing at least one 'x', anywhere in the filename
    <br> Answer: &nbsp;<tt>*x*</tt>
<li> filenames containing one or more digits, anywhere in the file name
    <br> Answer: &nbsp;<tt>*[0-9]*</tt>
<li> filenames which end with a dot and then exactly three further characters
    <br> Answer: &nbsp;<tt>*.???</tt>
<li> filenames beginning with an uppercase letter
    <br> Traditional answer: &nbsp;<tt>[A-Z]*</tt>
    <br> But that only works if the shell is using the ASCII character
    sequence, which is a configurable option these days.  For some language
    settings, upper and lower case letters are considered to be
    adjacent; in that case the simplest answer is probably:
    &nbsp;<tt>[ABCDEFGHIJKLMNOPQRSTUVWXYZ]*</tt>&nbsp;
    (although there are fancier alternatives too, using non-standard features)

<p>
<li> Given the following directory contents:
<pre>
	a.c   abcdef  b.c  b.x   bac
</pre>
For a given triple below, write a glob expression which matches those three
file names and not the other two.

<ul>
<li> a.c, b.c, and b.x
    <br> An answer: &nbsp;<tt>?.?</tt>
    <br> Another answer: &nbsp;<tt>*.*</tt>
    <br> -&gt; Remember that in unix, '.' in a file name is just another
    character.  It does not have a syntactic role in separating "filenames"
    and "extensions" as it does in some operating systems.
    A file name can contain many dots, or none.
<li> a.c, b.c, and bac
    <br> An answer: &nbsp;<tt>??c</tt>
<li> b.c, b.x, and bac
    <br> An answer: &nbsp;<tt>b??</tt>
<li> a.c, abcdef, and b.c
    <br> An answer: &nbsp;<tt>?[.b]c*</tt>
<li> a.c, abcdef, and b.x -- can't be done.
    <br> Examine the attempted solution 
    &nbsp;<tt>?[.b][cx]*</tt>
    &nbsp;and see why this is no good.
    <br> On the other hand, supposing for example that what we are trying to
    do is to "cat" these files, we could just type something like
    <blockquote>
	<tt>cat a* b.x</tt>
    </blockquote>
    or
    <blockquote>
	<tt>cat a* *x</tt>
    </blockquote>
    So we don't necessarily <i>have</i> to be able to match these files with
    a single glob expression!  (Which is good, because we can't.)

</ul>

</ol>

<p>
<hr>

<p>
Write a unix command to produce the requested output:

<ol>

<li> The number of lines in /etc/passwd.  (The file "/etc/passwd" lists
all user accounts on the system, one per line.)

<br> Answer: &nbsp;<tt>wc -l &lt;/etc/passwd</tt>
<br> (We redirect in /etc/passwd rather than supplying it on the command-line
so that "wc" will output (for example) "1234" instead of "1234 /etc/passwd".)

<li> The count of how many users have an 'e' in their user information somewhere
(anywhere in their line in /etc/passwd).

<br> Answer: &nbsp;<tt>grep e /etc/passwd | wc -l</tt>

<li> The contents of a file named:  <tt>&amp;@$%*</tt>

<br> Answer: &nbsp;<tt>cat '&@$%*'</tt>
<br>(The quotes are necessary -- this is the point of the question -- without
them, the characters '&', '$', and '*' will all be interpreted by the shell in
various ways which are not what we're trying to do here.  And when we talk
about the fairly complex rules for quoting in sh, you will see that they must
be single quotes, because if you use double-quotes, the shell will still
interpret the '$'.  We'll talk about this particular point in a week or so.)

<li> The alphabetically-first three lines in the file "abcdef", in order
(i.e. the earliest alphabetically, then the second-earliest, then the
third-earliest).

<br> An answer: &nbsp;<tt>sort abcdef | head -3</tt>

<li> All lines in the output of the "dumbproverb" command, but with every 'e'
character translated to a '?'.

<br> An answer: &nbsp;<tt>/student/csc209/tut/01/dumbproverb | tr e '?'</tt>
<br> (Again, '?' is special to the shell (glob notation) and needs to be
quoted to cause an actual question mark to be passed to the 'tr' command.
And again, although you probably used single-quotes in the tutorial, by the
time you're reading this you might be inclined to use a backslash instead
(a tiny savings in typing).)

<li> All file names in the current directory which contain a 'b'.

<br> One answer:  &nbsp;<tt>echo *b*</tt>
<br> Another answer: &nbsp;<tt>ls | grep b</tt>

<br> The answer "<tt>ls *b*</tt>" is not right because if any of those
items are directories, it will list their contents, not the directory name.
You <i>could</i> do "<tt>ls -d *b*</tt>".
But that's silly, to have 'ls' look up each file name when it's already the
expansion of the globbing.  You just want something to copy everything on the
command line to the output, and that's the 'echo' command.

<li> The number of people who logged in at exactly 10:45.

<br> One answer:  &nbsp;<tt>who | grep 10:45 | wc -l</tt>

<li> All lines of the file "abcdef" in the current directory which contain a
capital 'E'.

<br> Answer:  &nbsp;<tt>grep E abcdef</tt>

<li> The number of blocks used by the directory /usr/include, using "du".
But the output of "du /usr/include" has lines for each subdirectory and we only
want the last line, the one with the total.

<br> Answer:  &nbsp;<tt>du /usr/include | tail -1</tt>
<br> (better yet, pipe this to sed or something to remove the directory name,
since the question did ask for the number of blocks only)

<li> /student/csc209/tut/01/t2 is a text file listing integers, one per line.
Output the largest number in the file /student/csc209/tut/01/t2.

<br> An answer: &nbsp;<tt>sort -n /student/csc209/tut/01/t2 | tail -1</tt>
<br> Note that the '-n' is crucial.

</ol>

What is the difference between the shell "glob notation" (file pattern
matching) expressions "*" and "*.*" (without the quotes)?
State a file name which one of them would match and the other would not match.

<br> Answer: "*" matches all file names not beginning with a dot. "*.*" matches
file names not beginning with a dot but containing a dot elsewhere.  So a
file named "hello" (or just about anything not containing a dot) will be
matched by the first expression but not the second.


<p>
<hr>


<h3> sed </h3>

<p>
1. sed s/o/x/ only translates the first 'o' on each line.  How do you
translate them all?
<br>
Answer: &nbsp;<tt>sed s/o/x/g</tt>

<p>
2. Why aren't quotes needed around "s/o/x/" above?
<br>
Answer:
Because there aren't any characters there which are special to the shell.
With or without the quotes, the first argument to the 'sed' command will be
the six-character string "s/o/x/" (without the quotes).

<p>
3. Write the 'sed' command which translates names of the form "Madonna
Ciccone" to "Ciccone, Madonna" as demonstrated in the first lecture.
<br>
Answer:
&nbsp;<tt>sed 's/\(.*\) \(.*\)/\2, \1/'</tt>
<br>
Question:
Why are the quotes needed here but not in the earlier example?
<br>
Answer: Because the backslash, parentheses, asterisks, and even the spaces are
special characters to the shell.  With the quotes, the first argument to sed is
all that stuff there as you see it.  Without the quotes, the shell would
interpret these characters in various ways; for example, a backslash followed
by a parenthesis would just send a parenthesis (backslashes are another kind
of quoting available in the shell); the asterisks would be interpreted as file
name "glob" patterns; and the spaces would divide arguments as they usually do
so that not all of this string would be sent as the first argument, but it
would be sent as several arguments, which wouldn't make sense to sed at all
(it expects the pattern to be the first non-option argument).

<p>
(Items 4 and 5 are for submission; presumably everyone will get them, but if
you don't, please ask the instructor or a TA some time later -- the following
tutorial at the earliest.)

<p>
<hr>

</body>

<!-- Mirrored from www.cdf.toronto.edu/~ajr/209/tut/01/soln.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 13 Jan 2017 00:59:26 GMT -->
</html>

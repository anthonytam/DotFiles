<!doctype html>
<html>


<!-- Mirrored from www.cdf.toronto.edu/~ajr/209/notes/awk.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 13 Jan 2017 00:59:15 GMT -->
<head>

<title>CSC 209: The AWK programming language</title>

<meta name=viewport content="width=device-width, initial-scale=1">

<style type="text/css">
    body {
        color: black;
        background-color: #ffdddd;
    }
    hr {
        border-style: solid;
    }
    div.toc {
        float: right;
        padding-left: 20px;
        padding-right: 20px;
        padding-top: 20px;
        padding-bottom: 20px;
        background-color: #cc7777;
        color: white;
        link: white;
        visited: white;
        line-height: 150%;
    }
    div.toc a:link {
        color: white;
    }
    div.toc a:visited {
        color: white;
    }

    .hidden { display: none; }
    .unhidden { display: block; }
</style>

<script type="text/javascript">
    function show(s) {
        document.getElementById(s).className = 'unhidden';
    }
    function reveal(n) {
        document.getElementById(n + '_teaser').className = 'hidden';
        document.getElementById(n + '_hr').className = 'unhidden';
        document.getElementById(n + '_full').className = 'unhidden';
	n1 = n + 1;
        document.getElementById(n1 + '_hr').className = 'unhidden';
    }
</script>

</head>

<body>
<div class=toc>

<a href="../.html">Introduction</a>
<br>
<a href="../announce.html">Announcements</a>

<p>

<a href="../lect/index.html">Lectures</a>
<br>
<a href="../tut/index.html">Tutorials</a>
<br>
<a href="../asmt.html">Assignments</a>

<p>
<a href="javascript:show('tests')">Tests, exam</a>
<div id=tests class=hidden>
    <ul>
    <li>
    <a href="../mid/index.html">Mid-term test</a>
    <li>
    <a href="../exam/info.html">Final exam</a>
    </ul>
</div>

<p>

<a href="index.html">Course notes</a>
<br>
<a href="../probs/index.html">Extra problems</a>
<br>

<a href="https://mcs.utm.utoronto.ca/~mybb/utmcs/forumdisplay.php?fid=193">Discussion board</a>

<p>
<a href="../netgrade-results.html">Grades so far</a>
<br>
<a href="../oldannounce.html">Old announcements</a>

</div>

<h1>Awk</h1>

Awk is a programming language,
at least as much as 'sh' is a programming language.
It's a pattern matcher.  It is good for a lot of file-munging kinds of tasks.

<p>
Its programming language looks a bit more like C, except that it's got a
shell-ish syntactic approach; for example, newlines are significant.
However, it does not have the shell's bizarre inverse quoting rules;
strings do need to be in double-quotes.  It is more like a normal
programming language than the shell in terms of some of the basic syntax.

<p>
On the other hand, it is still a somewhat-specialized programming language.
<br>
An awk program is a loop over the lines.

<p>
So
<pre>
{
    print
}
</pre>
is like a 'cat'.

<p>
To execute this awk program, we could type:  <code>awk '{ print }'</code>

<p>
Some of the newlines above are not actually required (and are not present when
we type <code>awk '{ print }'</code>).
We would only attempt this newline elimination for very short awk programs.

<p>
What looks like sh's positional parameters ($1 through $9, although there is
no limit of 9 in awk) refers to fields on the current line.  So for example,
<pre>
awk '{ print $1 }'
</pre>
outputs the first field of every input line (try it!).

<p>
<hr noshade>

<p>
Here is a slightly more exciting awk program.
From here on in I will usually write awk programs so that they are actually
shell scripts, that is including the invocation of awk so that we get
something which we would pass to sh, not directly to awk.
Sh will then invoke awk.
We do this a lot, and we can throw in other cute interactions between sh and
awk as illustrated eventually below.
<pre>
awk '
$1 == "foo" {
    print
}
$1 == "bar" {
    print "bar"
}'
</pre>
If a boolean expression ("if ()" contents)
appears before the left brace, then that clause is only executed for lines
for which the boolean expression is true.
Thus
this awk program prints "bar" (but nothing else) for each input line whose first
field is "bar", and prints the entire input line if the first field is "foo".
"print" with no parameters prints the entire input line.
You can also refer to the entire current input line as "$0".

<p>
print emits an implied newline.
Comma-separated things are separated by the
separator character, which is space by default.

<p>
printf (as opposed to "print") doesn't have this implied newline.
The awk "printf" statement has a first parameter which is the format string,
like printf in the C library, and subsequent parameters are referred to by '%'
items in the format string.
<pre>
awk '
$1 == "foo" {
    print
}
$1 == "bar" {
    printf "bar %d\n", 2+3
}'
</pre>


<p>
<hr noshade>
<p>

Let us now write an awk program which takes input which looks like:
<pre>
3 4 Sally
5 12 Alan
1 9
6 8 Fred
</pre>
and produces output like:
<pre>
Sally 7
Alan 17
unknown 10
Fred 14
</pre>

<p>
Here is an awk program to do that:
<pre>
awk '
NF == 2 {
    print "unknown", $1 + $2
}
NF != 2 {
    print $3, $1 + $2
}'
</pre>

<p>
Those expressions before the list of statements in braces can also be regular expression patterns;
<br>
they can be absent to match all lines (as done at the beginning above);
<br>
they can also be BEGIN or END to specify code to be executed one time before
or after all line processing.

<p>
The following awk program sums a list of input numbers, one per line:
<pre>
awk '
BEGIN {
    x = 0
}
{
    x += $1
}
END {
    print x
}'
</pre>

<p>
As in sh, you don't declare variables; just start using them.
However, since strings do require double-quotes, we don't need to have any
variable introducer like sh's "$" (and indeed we don't have any such thing).

<p>
NF is a special variable which is the field count for the current line: how
many fields there are.

<p>
NR is the current line number ("record").

<p>
if, for, while, and do-while are like in C, including the optional braces to
have more than one statement in the body.

<p>
The "next" statement means that we are done processing for this line, and no
other clauses are considered for execution.  It's rather like C's "continue"
statement.  For example,
instead of the second-previous program we could have:
<pre>
awk '
NF == 2 {
    print "unknown", $1 + $2
    next
}
{
    print $3, $1 + $2
}'
</pre>

<p>
There is also an "exit" statement:
In the main loop, this advances to the END clause if any; in the END clause, it
exits really.
In either case, no further lines are processed.

<p>
<hr noshade>

<p>
In awk, quite unlike C, strings are "first-class values" -- you can pass them
around, you can store them in variables, they can be the value of an
expression, etc.
So we need a few new operators.

<p>
The string concatenation operator is simply juxtaposition.
If x is "world" and we want to set y to be the string "Hello, world", we can write
<pre>
y = "Hello, " x
</pre>

<p>
You can compare strings for equality, just with "a == b".
<br>
There is also a regular-expression-matching operator, "~":
<br>
"$1 ~ /A..n/" means that (i.e. tests whether) $1 is a four-character
string whose first character is 'A' and last is 'n'.
There's a corresponding "!~" operator.

<p>
Other string functions:
<ul>
<li> <code>length(s)</code> -- returns an integer which is the length of the
string.  Often used in conjunction with substr():
<li> <code>substr(s, i, len)</code> -- returns a portion of the string,
starting at index i (i is one-origin), taking up to len characters (it's
allowed for the string to end sooner than that)
<li> <code>index(s, t)</code> -- returns an integer index of string "t" as a
substring of string "s", first occurrence.  Also one-origin.  0 for not found.
<li> <code>split(s, newarray, separators)</code> -- invokes awk's tokenization
algorithm on the string, possibly with a different separator than what you're
using overall in this awk program, and puts it as a bunch of array members in
"newarray".  We didn't do an example of this; I just think you should remember
(perhaps just vaguely) that it exists for possible future reference, outside
this course.
</ul>

<p>
Since strings are first-class values, the sprintf() function does not need its
parameter which in C indicates a target char array in which to store its result.
Instead, the format string and all '%'-invoked arguments are the only
parameters to awk's sprintf() function, and it returns a value.
<pre>
x = sprintf(...)
</pre>

<p>
$0 is the whole line.  E.g. "print" (with no arguments) is short for "print $0".

<p>
<hr noshade>

<p>
"associative arrays" -- arrays which are indexed by anything.
A very nifty and useful data structure.

<p>
Word frequency count, assuming one word per line and no punctuation and such
(perhaps achieved with a cute 'tr' command):
<pre>
awk '
{
    freq[$1]++
}
END {
    for (i in freq)
	print i, freq[i]
}'
</pre>

<p>
Speaking of cute 'tr' commands, the pipeline used to demonstrate this in
lecture was
<pre>
tr -cs a-zA-Z \\012 | tr A-Z a-z | awk '<i>above stuff</i>'
</pre>

<p>
<hr noshade>

<p>
Kernighan, Aho, and Weinberger, <cite>The AWK Programming Language</cite>
<p>
"man awk"

<p>
awk -F to change separator

<p>
<pre>
awk -F: '
{
    printf "%s has uid %s\n", $1, $3
}' /etc/passwd
</pre>

<p>
'#' introduces a comment, to the end of the line.
<p>
#!/bin/awk ... or is that /usr/bin?  There's no PATH facility for the "#!" line...
<br>
so instead use
<br>
awk -f file  -- means that 'file' is the awk program, rather than argv[1].
<br>
or just embed it in your sh script in single quotes.
As you will have noticed by now, we're allowed to have newlines within single
quotes in sh.  The newline is part of the argv member string.

<p>
Passing in shell variables:
<pre>
if [ "$level" = novice ]
then
    uid='user id number'
else
    uid=uid
fi

awk -F: '
{
    printf "%s has '"$uid"' %s\n", $1, $3
}' /etc/passwd
</pre>

<p>
Note carefully that sequence:  <code>'"$uid"'</code>
<br>
The surrounding single quotes are actually putting the sequence
<code>"$uid"</code> <i>outside</i> the single quotes we're already in.
That is, the first single quote is ending the single quote started on the
<code>awk -F:</code> line, and the later single quote resumes
single-quoting.  This is allowed; if there's no unquoted space inbetween them,
we'll still be putting together the same argv member string.

<p>
Which is why we need to put "$uid" in double-quotes.
If that variable's value has a space in it (which is one of the 'if' forks;
it's quite possible), we want that <i>not</i> to stop one argv string and
start another.

<p>
This is tricky.  I think that you should be <i>able</i> to analyze what's
happening as above, but I think that it's fine if you wouldn't be able to
<i>come up with</i> this temporarily-stopping-the-single-quotes
strategy.

<p>
<hr noshade>
<p>
One further awk topic:
output to files.
<p>
You can use '>' in print and printf statements.  It's a special syntactic
character which is part of the print and printf statement syntax.
<pre>
print "something" >"/tmp/ajr"
</pre>
Note the use of quotes around the file name because it is a string.
We need quotes in awk as much as in C, unlike as in sh.

<p>
<hr>

</body>

<!-- Mirrored from www.cdf.toronto.edu/~ajr/209/notes/awk.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 13 Jan 2017 00:59:15 GMT -->
</html>

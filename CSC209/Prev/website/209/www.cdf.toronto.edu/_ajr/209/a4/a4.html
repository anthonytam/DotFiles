<!doctype html>
<html>


<!-- Mirrored from www.cdf.toronto.edu/~ajr/209/a4/a4.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 13 Jan 2017 00:59:11 GMT -->
<head>

<title>CSC 209 assignment four</title>

<meta name=viewport content="width=device-width, initial-scale=1">

<style type="text/css">
    body {
        color: black;
        background-color: #ffdddd;
    }
    hr {
        border-style: solid;
    }
    div.toc {
        float: right;
        padding-left: 20px;
        padding-right: 20px;
        padding-top: 20px;
        padding-bottom: 20px;
        background-color: #cc7777;
        color: white;
        link: white;
        visited: white;
        line-height: 150%;
    }
    div.toc a:link {
        color: white;
    }
    div.toc a:visited {
        color: white;
    }

    .hidden { display: none; }
    .unhidden { display: block; }
</style>

<script type="text/javascript">
    function show(s) {
        document.getElementById(s).className = 'unhidden';
    }
    function reveal(n) {
        document.getElementById(n + '_teaser').className = 'hidden';
        document.getElementById(n + '_hr').className = 'unhidden';
        document.getElementById(n + '_full').className = 'unhidden';
	n1 = n + 1;
        document.getElementById(n1 + '_hr').className = 'unhidden';
    }
</script>

</head>

<body>
<div class=toc>

<a href="../.html">Introduction</a>
<br>
<a href="../announce.html">Announcements</a>

<p>

<a href="../lect/index.html">Lectures</a>
<br>
<a href="../tut/index.html">Tutorials</a>
<br>
<a href="../asmt.html">Assignments</a>

<p>
<a href="javascript:show('tests')">Tests, exam</a>
<div id=tests class=hidden>
    <ul>
    <li>
    <a href="../mid/index.html">Mid-term test</a>
    <li>
    <a href="../exam/info.html">Final exam</a>
    </ul>
</div>

<p>

<a href="../notes/index.html">Course notes</a>
<br>
<a href="../probs/index.html">Extra problems</a>
<br>

<a href="https://mcs.utm.utoronto.ca/~mybb/utmcs/forumdisplay.php?fid=193">Discussion board</a>

<p>
<a href="../netgrade-results.html">Grades so far</a>
<br>
<a href="../oldannounce.html">Old announcements</a>

</div>

<h1> CSC 209 Assignment 4, Winter 2016: Chat Bot </h1>

Due by the end of <strong>Monday</strong> April 4, 2016;
no late assignments without written explanation.

<p>
In this assignment you will write a program which functions as a "bot".
I have written a simple chat server.  Your program will connect to this chat
server and in addition to being a normally-functioning client, it will respond
to certain messages sent by other users.
<p>
Your program will sign in with the user name "Marvin".
When another user says "Hey Marvin," (case-insensitive comparison)
followed by an arithmetic expression,
your program will compute this expression and reply "Hey [username],
[result]".
<p>
One of the distributed files is parse.c, which can parse and compute the value
of these expressions.  See testparse.c for a demonstration of how to use it.
Note how it reports syntax errors through a global variable
"errorstatus".  When this occurs, Marvin should instead say "Hey
[username], I don't like that.".
Additionally, display the error condition on stdout in square brackets (this
is mostly to help you in debugging, but do leave it in because it could also
help in debugging a future other "bot").
<p>
The user of your program can also type messages on stdin, and the program
shows everything from the server on stdout.
Thus if no one says "Hey Marvin,", the only difference
between this and a proper chat client is that it doesn't let you enter your
"handle".
<p>
Note that the supplied chat server broadcasts all messages to all clients,
including the client that sent them;
thus your user will see the messages you generate,
prefaced by "Marvin:".
(That is, you don't have to do anything to make this happen.)
<p>
The invocation syntax for your program will be like that of telnet,
or similar to nc:
argv[1] is a mandatory hostname; argv[2] is an optional port number.
The default port number is 1234.
Thus you do not need to use getopt() in your program,
although getopt() is used in the
supplied server where "-p" introduces the port number.


<h2>The chatsvr protocol</h2>

There is a specific, although simple, protocol for communicating with chatsvr.
Upon connection, the chatsvr sends the string "chatsvr 305975789",
followed by a network newline.  (You should get this string from the #define
in chatsvr.h.)  Check this string, because if you get something else, you are
talking to a different program.  (You can test this check by running something
like "marvin cslinux.utm.utoronto.ca 22".)
<p>
The client program then first has to send a "handle" that the user will be
known as (followed by a network newline).
The maximum handle length is MAXHANDLE in chatsvr.h.
<p>
After that, at any time the client can send a line which the user has typed,
and the server may send data which other people have typed.
The data from the client is free-format, with a maximum string length (not
including the newline) of MAXMESSAGE in chatsvr.h.
The data from the server will consist of the other user's handle, colon,
space, then the message; this is meant to be a form suitable for direct
display to the client (after converting the network newline).
<p>
Note that you can connect with "nc" to experiment with the raw
protocol; remember that the first line is your handle.  There is also a
supplied compiled "chatclient" program you can use, as well as a supplied
compiled "marvin" for comparison.  Make multiple connections to see it
from all angles.
<p>
There are firewall rules between the DH 2020 computers which you will need
to comply with to do any testing between different computers.
You can use port numbers 20000 to 21000 for your testing because they are not
blocked between the DH 2020 workstations, nor between them and
cslinux.utm.utoronto.ca.

<p>
Note that your assignment submission must work with anything which implements
the specified protocol, not only the example server and client.
For this reason and to deal with the entire range of allowable TCP behaviour,
you need to read characters in a loop until you see the network newline; you
can't assume that you will get a line all at once.
<p>
The example server code does this correctly, and your code for reading a line
from the server should be based on what the server does with each client
(buffering a line until it is complete, and recognizing that a single read()
call might return both the end of one line and the beginning of the next).
The supplied "trickyserver" isn't a full chat server, but you can use it
with your client in order to test your behaviour in the event of some
more-difficult clustering of data as reported by read().  Compare your
program's behaviour to that of the supplied compiled client or marvin programs.


<p>
<h2>Implementation sequence</h2>

I suggest first connecting to a running server, from several different
windows,
probably from both nc and from chatclient, and also using my compiled
"marvin".
Type assorted chat text, and also invoke Marvin's automated response, with
well-formed expressions and with syntax errors.
Then, I suggest implementing in the following sequence:

<p>
1.
Process the command-line arguments,
connect to the server (using the host
name lookup code from the supplied lookup.c),
and send the handle "Marvin".
(You can test it at this point -- look at the server output to see that it got
the "Marvin" handle.)  You should be checking the banner before
sending the handle, but that requires code you'll write in step 3 (and don't
worry if the server says "Broken pipe" at this point).
<p>
2.
Use select() to choose amongst server or stdin for next data.
<p>
3.
Process data from the server similar to myreadline() in
chatsvr.c.  (<i>Very</i> similar.)  However, data from stdin can simply be
read with fgets().
Use your myreadline()-like code to read the banner, too.  A difference in
reading the banner is that
you have to keep reading until you have the entire banner line, unlike the
usual network read in which you do only a single read() to avoid blocking.
In my solution for banner-checking I simply call my reading function in a
loop until it has an entire line.
<p>
At this point you have a complete chat client which you can test.
<p>
4.
After printing the data from the server, check whether it has the
appropriate form for a request which you need to process.
<p>
5.
Call parse() and everything,
print to stdout if
it's an error,
and send to the server in either case.

<p>
And remember to Keep It Simple.


<h2>Other notes</h2>

You will want to begin by making a subdirectory to hold the .c files.
You'll want to copy in the supplied .c and .h files from /student/csc209/a4,
e.g. "<tt>cp&nbsp;/student/csc209/a4/*.[ch]&nbsp;.</tt>".
To compile your program you will use a command such as "<tt>gcc -Wall
marvin.c parse.c util.c</tt>".  Or, it would be good practice to produce
a Makefile; it will not be graded, but you're welcome to ask me questions
about it.
<p>
Your program must be in standard C.
It must compile on the UTM linux machines with "gcc&nbsp;-Wall" with the original
chatsvr.h, parse.c, parse.h, util.c, and util.h,
with no
errors or warning messages, and may not use linux-specific or GNU-specific
features.
<p>
When running a test server, if you get "address already in use", this
might mean that another user is
using the same port number on the same machine;
<i>or</i> it might simply be you.
After your program exits, the port number is still marked as in-use for a
few minutes to make the behaviour caused by stray packets less confusing.
This is why the server has the "-p" option.
<p>
Check errors from <i>every</i> system call, with the possible exception of
write()s to sockets.
You needn't handle errors in a sophisticated way,
but you should at least call perror() for unexpected errors,
and you <i>must not</i> perform subsequent system calls which no longer make
sense given the previous error condition.
For example, if socket() fails, do <i>not</i> try to bind to file descriptor
-1.
<p>
As always, keep it simple; avoid frills which introduce bugs or complexity
and don't significantly enhance the value of the program.
<p>
Please see the assignment Q&amp;A web page at
<a href="qna.html">https://cs.utm.utoronto.ca/~ajr/209/a4/qna.html</a>
for other reminders, and answers to common questions.


<h2>To submit</h2>

Once you are satisfied with your code, you can submit it for grading
with the command
<pre>
	/student/csc209/submit a4 marvin.c
</pre>
and the other "submit" commands are also as before.
Your marvin.c file will be compiled with the original versions of chatsvr.h,
parse.[ch], and util.[ch] for automated testing.

<p>
<hr>

</body>

<!-- Mirrored from www.cdf.toronto.edu/~ajr/209/a4/a4.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 13 Jan 2017 00:59:11 GMT -->
</html>

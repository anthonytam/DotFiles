<!doctype html>
<html>


<!-- Mirrored from www.cdf.toronto.edu/~ajr/209/a4/qnaall.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 13 Jan 2017 00:59:48 GMT -->
<head>

<title>CSC 209 assignment four questions and answers</title>

<meta name=viewport content="width=device-width, initial-scale=1">

<style type="text/css">
    body {
        color: black;
        background-color: #ffdddd;
    }
    hr {
        border-style: solid;
    }
    div.toc {
        float: right;
        padding-left: 20px;
        padding-right: 20px;
        padding-top: 20px;
        padding-bottom: 20px;
        background-color: #cc7777;
        color: white;
        link: white;
        visited: white;
        line-height: 150%;
    }
    div.toc a:link {
        color: white;
    }
    div.toc a:visited {
        color: white;
    }

    .hidden { display: none; }
    .unhidden { display: block; }
</style>

<script type="text/javascript">
    function show(s) {
        document.getElementById(s).className = 'unhidden';
    }
    function reveal(n) {
        document.getElementById(n + '_teaser').className = 'hidden';
        document.getElementById(n + '_hr').className = 'unhidden';
        document.getElementById(n + '_full').className = 'unhidden';
	n1 = n + 1;
        document.getElementById(n1 + '_hr').className = 'unhidden';
    }
</script>

</head>

<body>
<div class=toc>

<a href="../.html">Introduction</a>
<br>
<a href="../announce.html">Announcements</a>

<p>

<a href="../lect/index.html">Lectures</a>
<br>
<a href="../tut/index.html">Tutorials</a>
<br>
<a href="../asmt.html">Assignments</a>

<p>
<a href="javascript:show('tests')">Tests, exam</a>
<div id=tests class=hidden>
    <ul>
    <li>
    <a href="../mid/index.html">Mid-term test</a>
    <li>
    <a href="../exam/info.html">Final exam</a>
    </ul>
</div>

<p>

<a href="../notes/index.html">Course notes</a>
<br>
<a href="../probs/index.html">Extra problems</a>
<br>

<a href="https://mcs.utm.utoronto.ca/~mybb/utmcs/forumdisplay.php?fid=193">Discussion board</a>

<p>
<a href="../netgrade-results.html">Grades so far</a>
<br>
<a href="../oldannounce.html">Old announcements</a>

</div>

<h1>Assignment four questions and answers</h1>

Here are some questions and answers about assignment four, and other notes.
Suggestions for additions to this list are welcome (e.g. via e-mail).


<p><hr><p>
Example code:
<ul>
<li> <a href="../notes/sockets/index.html">socket examples presented and discussed in
class</a>
<li> examples in chapter 10 of the Haviland et al textbook
<li> I've written an explanation of <a href="../notes/sockets/newline.html">the network newline convention</a>
<!--
<li> <a href="muffinman.c">muffinman.c</a> (try it out, telnet to it, answer
yes or no, have a few simultaneous connections)
-->
<!--
<li> the <a href="../tut/09/">linked-list tutorial</a>
(and solutions to the last bits in the directory
/student/csc209/tut/soln/09)
-->
<li> compiled solution in /student/csc209/a4/marvin
<li> /student/csc209/a4/<a href="lookup.c">lookup.c</a>
for the code to look up a host name to get an IP address
</ul>

<p>
Note:  <strong>Do not</strong> copy any code which you don't understand into
your program, whether it's from the samples above or stuff you find on the
net or in a book.
If you do this,
there end up being bits in your
program which you don't understand and are strange or silly.

<p>
I really mean the advice in the previous paragraph.
If you have code in your program for no reason other than that it was in some
other file, you will not get your program working.  Really!

<p>
Above all, <strong><font size="+1">Keep It Simple!</font></strong>

<p>
<font size="+2">And</font>, I would like to bring back to your attention the
<a href="../a3/qna-segfault.html">"various segfault problems" entry in the
assignment three Q&amp;A file</a>, which gives some
general advice.

<p>
Also see <a href="strcasecmp.html">strcasecmp.html</a> regarding how to parse
the "Hey&nbsp;Marvin" line.


<p><hr><p>
Q: How does the code in lookup.c work?

<p>
A: Ok, this is an exception to my advice never to copy in code which you don't
understand.  I can explain this code best in person but it's a bit tricky, but
it's standard and you can copy it.

<p>
The short version is that gethostbyname() returns the lookup information in
a format which is extremely general, and able to represent host names on
multiple different kinds of networks, and able to represent multiple IP
addresses (or other address information) per host, and so on.  So extracting
this information specifically for internet hosts is a bit involved, and the
code there is the way to do it, and you can copy this into your marvin.c.


<p><hr><p>
Just about the easiest way to write a fixed message to a socket is
like this:
<pre>
        static char msg[] = "Hello, world\r\n";
        write(fd, msg, sizeof msg - 1);
</pre>
(That might look like an "array reference" declaration like in java, but
actually what that means in C is that the compiler is to determine the array
size from the initializer.)

<p>
"sizeof msg" includes the terminating zero byte, which we do <i>not</i> want
to write.
Similarly, if you make up a string to write to a socket, the number of bytes
to write is strlen(buf), <i>not</i> strlen(buf)+1.

<p>
(Note that sizeof is only of use here because there is a relation between the
size of the data object and the length of the string.  You can't use sizeof if
you declare an array and <i>then</i> fill it up (it will give you the size
of the array, not of the portion of it which is a zero-terminated string);
and you can't use sizeof on a string passed as a parameter to a function (what
you pass is a pointer to the zeroth element of the string, and sizeof that
is the storage requirements of the pointer, not of the array it points to the
zeroth element of).)


<p><hr><p>
Q: Hey, you're using sizeof to find the number of elements in the array!
You kept saying that there was no way to do this in C!

<p>
A: sizeof tells you the size of an object or type, in bytes.  It's only
useful in very specific circumstances.

<p>
If you have a function with a header like this:

<p>
<pre>
        int f(int *a)
        {
            ...
</pre>

<p>
then "sizeof a" will be 8 on the DH 2020 linux machines, because that's the
number of bytes in a pointer-to-int on these machines.

<p>
But maybe you think you will cleverly write instead

<p>
<pre>
        int f(int a[])
        {
            ...
</pre>

<p>
Well, "sizeof a" will still be 8, because as I've said in class, the 'a' there
is really a pointer, due to a special conversion rule which applies only
inside formal parameter lists.  This is why I strongly recommend against using
the above syntax, because it looks like it's giving you something it isn't.
It looks like an array, but it is actually a pointer.

<p>
So "sizeof" doesn't always tell you the size of something in high-level terms,
and furthermore, wrt assignment four, note that
it does not tell you the number of bytes you need to transmit over the
network, in hardly any circumstances.

<p>
If you have
<pre>
        char buf[300];
</pre>
then "sizeof buf" is 300 (since "sizeof(char)" is always 1, i.e. the units of
sizeof are chars).

<p>
This value might be useful for some purposes, e.g. in indicating the amount
of buffer space available to a read() or fgets().
But it is not useful in a write(), because you don't want to transmit 300
bytes.  And if you pass this to a function, it decays into a pointer to its
zeroth element, and the sizeof of that is something like 8; this is probably
not of any use to you.

<p>
If you want to transmit "hi\r\n", for example, that's 4 bytes.

<p>
So this is also wrong:
<pre>
        char msg[] = "hi\r\n";
        write(fd, msg, sizeof msg);     WRONG WRONG WRONG
</pre>
because sizeof msg is 5, including the terminating zero byte, but you want to
transmit 4 bytes.

<p>
So you have to figure out how many bytes you want to transmit.
This is not always trivial.

<p>
read() returns a byte count.  You need to store that.
read() does not produce a zero-terminated string.  You can assign the '\0'
to a member of the array
in a separate C statement if you want it there.


<p><hr><p>
Q: What is the first argument to select()?

<p>
A: The max of all of the file descriptor numbers in all of the fd sets, plus one
.
See chatsvr.c
<!-- or <a href="muffinman.c">muffinman.c</a> -->
for a server-oriented example of this;
and despite the name,
<a href="../notes/sockets/server_select.c">notes/sockets/server_select.c</a>
is a somewhat more client-side-oriented example in that it is select()ing
amongst a small, fixed number of sockets (including stdin!).
<!--
In your server, you need a loop to add all of the fds to the fd_set variable,
and another loop to check FD_ISSET on all of them.
-->


<p><hr><p>
Q: What value do I use as the timeout for select()?  Does it matter?

<p>
A: Yes, it matters.  Specifically, you must not have a timeout.
<!-- (in either the client or the server). -->
You want to block until something happens.  There is no time limit.
Thus the last argument to select() is simply NULL.


<p><hr><p>
Review of the FD_* macros:
<br>
I think that the FD_* macros cause some of their confusion
simply because of the terminology embodied in their names.
They use terminology reminiscent of digital logic (e.g. CSC 258), based on the
fact that you are turning on and off bits in a word.

<p>
So, the function to set the value to the empty set is FD_ZERO, because it sets
the value of that int (or long or whatever it is) to the integer zero, which
has all bits zero, which means that no elements are in the set.

<p>
The function FD_SET "sets" the bit, meaning that it makes it one.
The function FD_CLR "clears" the bit, meaning that it makes it zero.

<p>
Similarly, "FD_ISSET" is not checking whether or not something is a
mathematical set; it's checking whether a bit is set, which means that the
given item is an element of that fdlist.

<p>
You may prefer to use more modern abstract-data-type terminology:
<ul>
<li> fd_set: type of a set of file descriptors (a "set" abstract data type is
like a list, but is unordered)
<li> FD_ZERO: make the fd_set value the empty set (ignore the word "ZERO")
<li> FD_SET: add the fd value into the fd_set value (ignore the word "SET")
<li> FD_CLR: remove the fd value from the fd_set value
<li> FD_ISSET: check whether the fd value is in the fd_set (ignore the word "SET" -- it's "IS_MEMBER", and the subject of this predicate is the fd)
</ul>


<p>
I think I may be able to answer some (most?) remaining confusion about the
FD_* macros by presenting a sample implementation.
This would be put into a system include file, either &lt;unistd.h> or some
other file it #includes.
This implementation assumes a maximum fd of 31, and that ints are at least 32
bits (so as to hold a bit for each of fds 0, 1, 2, ..., 31).

<p>
<pre>
#define FD_SETSIZE 32
typedef int fd_set;
#define FD_ZERO(p) (*(p) = 0)
#define FD_SET(fd,p) (*(p) |= 1 &lt;&lt; (fd))
#define FD_CLR(fd,p) (*(p) &= ~(1 &lt;&lt; (fd)))
#define FD_ISSET(fd,p) (*(p) & (1 &lt;&lt; (fd)))
</pre>

<p>
On the other hand, the above might not clarify matters if you are a stranger
to this "bit-twiddling".
I will explain it in person to anyone who is interested, but you don't have to
understand it for this course.
Basically, the terminology used in the FD_* macros is excessively low-level,
and if you are familiar with some of these low-level matters, the above might
help bring it together, I hope.
If you aren't, that's ok; consider the semantics to be as listed previously
(before this sample implementation).


<p><hr><p>
Q: Is it ok to use O_NONBLOCK instead of select()?

<p>
A: No.  Going through all the idle sockets in a loop and checking for
activity is called "busy-waiting" -- you really have no work to do, but
you're spending a lot of time doing it.
This takes away processing power from other processes on the same machine.

<p>
Have you ever had a program on your home computer which when it's running,
everything else is sluggish, even if that program is just sitting idle?
So you see that the computer is sluggish and you go "oh, I must have fooglop
running" and you switch to it and quit it and all's well.

<p>
The problem with that program was that it was busy-waiting instead of doing
something like select().  It's a big problem when a program does this.


<p><hr><p>
When the other side of a socket connection disconnects,
that socket fd is considered by select() to have read-oriented
activity, so select() will tell you that there's activity on that fd, and
thus you'll do a
read, and you'll get zero bytes, and that is the signal that the connection
has been dropped.
That is to say, check if the read() return value is zero.  Negative means
error, zero means EOF, and positive indicates the number of data bytes read.
(If there are no bytes to be read, read() blocks until there are!)

<p>
In your client, when the server sends EOF, that means it has exited or for
some reason has hung up on you (which won't happen if you are following the
protocol).  Just print a simple message to stdout (such as "Server shut
down\n") and exit.


<p><hr><p>
Q: What's this "localhost" thing about?

<p>
A: We discussed in lecture how 127.0.0.1 is a special IP address which "loops
back" to the machine you're already on.

<p>
But we normally use host names, not IP addresses, when running programs.
For example, you type "www.utm.utoronto.ca" into your web browser instead of
142.150.1.50.

<p>
The name "localhost" translates to the IP address 127.0.0.1.
Using either one on the command line will yield identical results
when you run marvin or chatclient.


<p><hr><p>
Note that you must not trust the server to send appropriately-sized messages.
See how the server does not trust the client.
Most importantly,
no matter what the other side sends,
there must be no buffer overrun errors.
If someone telnets to the server and types an extremely long line
and it gets split in two, fine; if it crashes, not fine.
If your program exceeds array bounds, then there is almost certainly a
possible input which makes it crash.

<p>
Buffer overrun errors are not only a concern for your communication with the
server, but are a general issue.
For example,
the following is <b><i>wrong</i></b>, for any size of <code>s</code>:

<p>
<pre>
        if (fgets(s, sizeof s, fp) == NULL)
            ...
        strcat(s, ", and the same goes for you!");
</pre>

<p>
The fgets() might produce a string which is of the maximal size to be able to
fit into s; so the strcat (potentially) exceeds the array bounds.
C programs are only correct if you can prove that array bounds are not
exceeded.


<p><hr><p>
Q: What do I put in the fd set passed to select()?

<p>
A: You are interested in data on stdin (which is file descriptor 0) or data
from the server.
So you want both of these file descriptors in your fd_set value.
And remember that the first argument to select() is the max of these numbers
<strong>plus one</strong>.  Also, you can pre-compute the max of x and 0 for
any positive x.


<p><hr><p>
Q: What should I replace [...something in a socket example or some code from the net...] by in my code?

<p>
A: No.  You should not do this.  You should not start with some other program
and replace things.  You'll never get your program working that way.

<p>
You have to start with a blank file and only write things which you want your
program to do, for a good reason.  Of course you can copy bits of code from
elsewhere, but only because you know what they do and you have a good reason
for wanting your program to do them.

<p>
(And copied code other than from me or the textbook needs to be cited
appropriately, of course.)


<p><hr><p>
Q: How do you run <a href="../notes/gdb/index.html">gdb</a> if your program needs command-line arguments?

<p>
A: The command-line arguments appear as parameters to the "run" command in
gdb.

<p>
<pre>
        % gdb a.out
        (gdb) run localhost 1234
</pre>

<!--
<p>
And note that you can indeed use gdb quite normally on your a4 programs.
In assignment three, gdb was often not very effective because of the forking.
Here we still have multiple processes (client and server),
but they're manually invoked separately and
there is no subsequent forking; gdb works fine.
-->


<p><hr><p>
Q: How do I connect to a server using nc?

<p>
A: <!--/bin/-->nc hostname portnumber
<br>
e.g. if you are running a server on a computer called "glop" and it is
listening on port number 2345, type "<!--/bin/-->nc glop 2345".
Or you can use "localhost" if applicable, e.g. "<!--/bin/-->nc localhost 2345".

<p>
Q: How can I "play server" so that my client can connect to <i>me</i>?

<p>
A: <!--/bin/-->nc -l portnumber


<p><hr><p>
Q: Do we have to check all system calls for error return values?

<p>
A: Yes, pretty much.
Note that if you don't check error return values, you won't get good error
messages and this will impede your debugging of your program.  So put in the
error checks from the start.

<p>
When hanging up on the server, you probably can't do much with error
checking from close(), so you don't need to worry about that for this
assignment.
Also, you are not required to check all the write()s for errors.


<p><hr><p>
Q: Is marvin.c an infinite loop?

<p>
A: Yes, pretty much.  It exits in the case of various kinds of errors, and
also upon EOF on stdin.


<p><hr><p>
Q: Once I get data from one file descriptor, I can't seem to receive data from
<!--any of--> the other file descriptor<!--s--> any more.

<p>
A: Sometimes this is the result of passing an old
return value of the fd list back to select().  When select() returns, it has
modified its second parameter (the read fd list); this parameter is an
"in/out" parameter.
The modified value is not suitable for passing to select() again.

<p>
I suggest you put the FD_ZERO and list of FD_SETs in your main loop, just
before the select() call.  Just set up the fd list every time.

<p>
The textbook discusses a different strategy, in which we copy the fd list from
a master list every time.  This saves the setting-up overhead
(or, to be precise, it turns it into a single variable assignment).
This is good
for a program with a large number of connected sockets, in which the FD_ZERO
and list of FD_SETs would be significant.
But...

<p>
Don't do it.  Keep It Simple.
The textbook's strategy introduces a situation of what some call "parallel
data structures": your other variables which are keeping track of the
connection sockets contain data which is equivalent in semantics
to this master fd list.  The problem with parallel data structures is that
it's easy for them to get out of sync, and then you have a bug.  If they remain
perfectly synchronized you still have additional program coding requirements
resulting from having to maintain the parallel data structures.  Parallel
data structures should be avoided except when there is a compelling reason
for them (which usually in this case would be an efficiency concern).
<!--
You're not likely to have enough connections for it to make a difference,
so don't do it, especially for a course assignment.
-->
There are only two file descriptors in the set in this program,
so don't do it.


<p><hr><p>
Q: I got an unexpected message from my server saying that someone else had connected
(or sent something).

<p>
A: Someone else <i>did</i> connect (or send something).  It could have been
anyone on the planet with internet access.  Most likely it was another CSC 209
student.


<p><hr><p>
Q: Can I submit a "marvin.h"?  Do I #include "parse.c" and "util.c"?  Etc.

<p>
A: No.  Your submitted marvin.c will be compiled like this:
<pre>
        gcc -Wall marvin.c parse.c util.c
</pre>
using the original versions of chatsvr.h, parse.c, parse.h, util.c, and
util.h.

<p>
You #include the .h files, but you link with the .c files.

<p>
Any declarations you are wanting to put in a marvin.h file should simply go
towards the top of your marvin.c.  There will be no marvin.h.
<br>
.h files in C are for coordination <i>between</i> files; you are writing only
one .c file.
The C pre-processor just copies the file in when you #include it;
#include doesn't provide anything you can't just do in a single C file.

<p>
<!--
You may want to copy some code from socketutil.c,
especially from the myreadline() function.
You may end up copying some code from muffinman.c as well.
-->
You may want to copy some code from some of the socket example code presented
in lecture.  That's fine.

<p>
But don't copy any code which you don't understand.
If you copy it without understanding it,
<!--(e.g. if you begin with "cp sss.c ssc.c"),-->
you will get into trouble later.
And there isn't a lot of "later" time to straighten yourself out in!


<p><hr><p>
Q: What is inet_ntoa()?

<p>
A: It takes a 32-bit IP address and formats it as a nice string with dots
separating the octets.  E.g. to encode 192.168.3.28 as a 32-bit number is
(((192 * 256 + 168) * 256 + 3) * 256 + 28), or 3232236316.  Calling
printf("%ld\n", 3232236316) is going to produce this unintelligible output.
Calling printf("%s\n", inet_ntoa(3232236316)) will produce a nice
"192.168.3.28".
In case it helps explain inet_ntoa(),
<a href="my_inet_ntoa.c">here is a sample implementation.</a>

<p>
(Actually, the above calculations assume that the host byte order is
"big-endian" -- otherwise, there is a byte order issue, which inet_ntoa()
also takes care of, and the sample implementation I provide at that link does
this right as well, by looking at the raw bytes rather than using the host
"long integer" instructions.  On the other hand, my implementation assumes
that "long"s are 32 bits and that they are composed of four 8-bit bytes.
inet_ntoa() implementations are often platform-specific in this sort of way.)


<p><hr><p>
Q: When viewing messages from my marvin in 'nc' it goes to the left margin
of
the same line, so subsequent messages, or what I type, overwrites.
Is this ok?

<p>
A: No, this is not ok.  You are not sending the network newline properly; you
are just sending \r, or "CR", which means to go to the left.  You need to send
\r\n, or "CRLF", which is <a href="../notes/sockets/newline.html">the network
newline</a>.


<p><hr><p>
Q: Could we have the source code for chatclient?

<p>
A: Sorry; this is too similar to marvin.c.  I'll post it along with the
solutions.

<p>
<hr>

</body>

<!-- Mirrored from www.cdf.toronto.edu/~ajr/209/a4/qnaall.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 13 Jan 2017 00:59:48 GMT -->
</html>
